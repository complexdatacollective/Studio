diff --git a/dist/index.d.mts b/dist/index.d.mts
index 2224d2490e8a62116a97c63e3e5de002237f0aae..928cd9db08d55e8f5350ef93b89b4b814e6756a3 100644
--- a/dist/index.d.mts
+++ b/dist/index.d.mts
@@ -1,17 +1,19 @@
-import * as React from 'react';
-import * as ArrowPrimitive from '@radix-ui/react-arrow';
-import { Primitive } from '@radix-ui/react-primitive';
-import { Measurable } from '@radix-ui/rect';
+import * as React from "react";
+import * as ArrowPrimitive from "@radix-ui/react-arrow";
+import { Primitive } from "@radix-ui/react-primitive";
+import { Measurable } from "@radix-ui/rect";
 
-type Scope<C = any> = {
-    [scopeName: string]: React.Context<C>[];
-} | undefined;
+type Scope<C = any> =
+  | {
+      [scopeName: string]: React.Context<C>[];
+    }
+  | undefined;
 type ScopeHook = (scope: Scope) => {
-    [__scopeProp: string]: Scope;
+  [__scopeProp: string]: Scope;
 };
 interface CreateScope {
-    scopeName: string;
-    (): ScopeHook;
+  scopeName: string;
+  (): ScopeHook;
 }
 
 declare const SIDE_OPTIONS: readonly ["top", "right", "bottom", "left"];
@@ -20,37 +22,65 @@ type Side = (typeof SIDE_OPTIONS)[number];
 type Align = (typeof ALIGN_OPTIONS)[number];
 declare const createPopperScope: CreateScope;
 interface PopperProps {
-    children?: React.ReactNode;
+  children?: React.ReactNode;
 }
 declare const Popper: React.FC<PopperProps>;
 type PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;
 interface PopperAnchorProps extends PrimitiveDivProps {
-    virtualRef?: React.RefObject<Measurable>;
+  virtualRef?: React.RefObject<Measurable>;
 }
-declare const PopperAnchor: React.ForwardRefExoticComponent<PopperAnchorProps & React.RefAttributes<HTMLDivElement>>;
+declare const PopperAnchor: React.ForwardRefExoticComponent<
+  PopperAnchorProps & React.RefAttributes<HTMLDivElement>
+>;
 type Boundary = Element | null;
 interface PopperContentProps extends PrimitiveDivProps {
-    side?: Side;
-    sideOffset?: number;
-    align?: Align;
-    alignOffset?: number;
-    arrowPadding?: number;
-    avoidCollisions?: boolean;
-    collisionBoundary?: Boundary | Boundary[];
-    collisionPadding?: number | Partial<Record<Side, number>>;
-    sticky?: 'partial' | 'always';
-    hideWhenDetached?: boolean;
-    updatePositionStrategy?: 'optimized' | 'always';
-    onPlaced?: () => void;
+  side?: Side;
+  sideOffset?: number;
+  align?: Align;
+  alignOffset?: number;
+  arrowPadding?: number;
+  avoidCollisions?: boolean;
+  collisionBoundary?: Boundary | Boundary[];
+  collisionPadding?: number | Partial<Record<Side, number>>;
+  sticky?: "partial" | "always";
+  hideWhenDetached?: boolean;
+  updatePositionStrategy?: "optimized" | "always";
+  onPlaced?: () => void;
+  fallbackAxisSideDirection?: "start" | "end" | "none";
 }
-declare const PopperContent: React.ForwardRefExoticComponent<PopperContentProps & React.RefAttributes<HTMLDivElement>>;
+declare const PopperContent: React.ForwardRefExoticComponent<
+  PopperContentProps & React.RefAttributes<HTMLDivElement>
+>;
 type ArrowProps = React.ComponentPropsWithoutRef<typeof ArrowPrimitive.Root>;
-interface PopperArrowProps extends ArrowProps {
-}
-declare const PopperArrow: React.ForwardRefExoticComponent<PopperArrowProps & React.RefAttributes<SVGSVGElement>>;
+interface PopperArrowProps extends ArrowProps {}
+declare const PopperArrow: React.ForwardRefExoticComponent<
+  PopperArrowProps & React.RefAttributes<SVGSVGElement>
+>;
 declare const Root: React.FC<PopperProps>;
-declare const Anchor: React.ForwardRefExoticComponent<PopperAnchorProps & React.RefAttributes<HTMLDivElement>>;
-declare const Content: React.ForwardRefExoticComponent<PopperContentProps & React.RefAttributes<HTMLDivElement>>;
-declare const Arrow: React.ForwardRefExoticComponent<PopperArrowProps & React.RefAttributes<SVGSVGElement>>;
+declare const Anchor: React.ForwardRefExoticComponent<
+  PopperAnchorProps & React.RefAttributes<HTMLDivElement>
+>;
+declare const Content: React.ForwardRefExoticComponent<
+  PopperContentProps & React.RefAttributes<HTMLDivElement>
+>;
+declare const Arrow: React.ForwardRefExoticComponent<
+  PopperArrowProps & React.RefAttributes<SVGSVGElement>
+>;
 
-export { ALIGN_OPTIONS, Anchor, Arrow, Content, Popper, PopperAnchor, type PopperAnchorProps, PopperArrow, type PopperArrowProps, PopperContent, type PopperContentProps, type PopperProps, Root, SIDE_OPTIONS, createPopperScope };
+export {
+  ALIGN_OPTIONS,
+  Anchor,
+  Arrow,
+  Content,
+  Popper,
+  PopperAnchor,
+  type PopperAnchorProps,
+  PopperArrow,
+  type PopperArrowProps,
+  PopperContent,
+  type PopperContentProps,
+  type PopperProps,
+  Root,
+  SIDE_OPTIONS,
+  createPopperScope,
+};
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 2224d2490e8a62116a97c63e3e5de002237f0aae..928cd9db08d55e8f5350ef93b89b4b814e6756a3 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1,17 +1,19 @@
-import * as React from 'react';
-import * as ArrowPrimitive from '@radix-ui/react-arrow';
-import { Primitive } from '@radix-ui/react-primitive';
-import { Measurable } from '@radix-ui/rect';
+import * as React from "react";
+import * as ArrowPrimitive from "@radix-ui/react-arrow";
+import { Primitive } from "@radix-ui/react-primitive";
+import { Measurable } from "@radix-ui/rect";
 
-type Scope<C = any> = {
-    [scopeName: string]: React.Context<C>[];
-} | undefined;
+type Scope<C = any> =
+  | {
+      [scopeName: string]: React.Context<C>[];
+    }
+  | undefined;
 type ScopeHook = (scope: Scope) => {
-    [__scopeProp: string]: Scope;
+  [__scopeProp: string]: Scope;
 };
 interface CreateScope {
-    scopeName: string;
-    (): ScopeHook;
+  scopeName: string;
+  (): ScopeHook;
 }
 
 declare const SIDE_OPTIONS: readonly ["top", "right", "bottom", "left"];
@@ -20,37 +22,65 @@ type Side = (typeof SIDE_OPTIONS)[number];
 type Align = (typeof ALIGN_OPTIONS)[number];
 declare const createPopperScope: CreateScope;
 interface PopperProps {
-    children?: React.ReactNode;
+  children?: React.ReactNode;
 }
 declare const Popper: React.FC<PopperProps>;
 type PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;
 interface PopperAnchorProps extends PrimitiveDivProps {
-    virtualRef?: React.RefObject<Measurable>;
+  virtualRef?: React.RefObject<Measurable>;
 }
-declare const PopperAnchor: React.ForwardRefExoticComponent<PopperAnchorProps & React.RefAttributes<HTMLDivElement>>;
+declare const PopperAnchor: React.ForwardRefExoticComponent<
+  PopperAnchorProps & React.RefAttributes<HTMLDivElement>
+>;
 type Boundary = Element | null;
 interface PopperContentProps extends PrimitiveDivProps {
-    side?: Side;
-    sideOffset?: number;
-    align?: Align;
-    alignOffset?: number;
-    arrowPadding?: number;
-    avoidCollisions?: boolean;
-    collisionBoundary?: Boundary | Boundary[];
-    collisionPadding?: number | Partial<Record<Side, number>>;
-    sticky?: 'partial' | 'always';
-    hideWhenDetached?: boolean;
-    updatePositionStrategy?: 'optimized' | 'always';
-    onPlaced?: () => void;
+  side?: Side;
+  sideOffset?: number;
+  align?: Align;
+  alignOffset?: number;
+  arrowPadding?: number;
+  avoidCollisions?: boolean;
+  collisionBoundary?: Boundary | Boundary[];
+  collisionPadding?: number | Partial<Record<Side, number>>;
+  sticky?: "partial" | "always";
+  hideWhenDetached?: boolean;
+  updatePositionStrategy?: "optimized" | "always";
+  onPlaced?: () => void;
+  fallbackAxisSideDirection?: "start" | "end" | "none";
 }
-declare const PopperContent: React.ForwardRefExoticComponent<PopperContentProps & React.RefAttributes<HTMLDivElement>>;
+declare const PopperContent: React.ForwardRefExoticComponent<
+  PopperContentProps & React.RefAttributes<HTMLDivElement>
+>;
 type ArrowProps = React.ComponentPropsWithoutRef<typeof ArrowPrimitive.Root>;
-interface PopperArrowProps extends ArrowProps {
-}
-declare const PopperArrow: React.ForwardRefExoticComponent<PopperArrowProps & React.RefAttributes<SVGSVGElement>>;
+interface PopperArrowProps extends ArrowProps {}
+declare const PopperArrow: React.ForwardRefExoticComponent<
+  PopperArrowProps & React.RefAttributes<SVGSVGElement>
+>;
 declare const Root: React.FC<PopperProps>;
-declare const Anchor: React.ForwardRefExoticComponent<PopperAnchorProps & React.RefAttributes<HTMLDivElement>>;
-declare const Content: React.ForwardRefExoticComponent<PopperContentProps & React.RefAttributes<HTMLDivElement>>;
-declare const Arrow: React.ForwardRefExoticComponent<PopperArrowProps & React.RefAttributes<SVGSVGElement>>;
+declare const Anchor: React.ForwardRefExoticComponent<
+  PopperAnchorProps & React.RefAttributes<HTMLDivElement>
+>;
+declare const Content: React.ForwardRefExoticComponent<
+  PopperContentProps & React.RefAttributes<HTMLDivElement>
+>;
+declare const Arrow: React.ForwardRefExoticComponent<
+  PopperArrowProps & React.RefAttributes<SVGSVGElement>
+>;
 
-export { ALIGN_OPTIONS, Anchor, Arrow, Content, Popper, PopperAnchor, type PopperAnchorProps, PopperArrow, type PopperArrowProps, PopperContent, type PopperContentProps, type PopperProps, Root, SIDE_OPTIONS, createPopperScope };
+export {
+  ALIGN_OPTIONS,
+  Anchor,
+  Arrow,
+  Content,
+  Popper,
+  PopperAnchor,
+  type PopperAnchorProps,
+  PopperArrow,
+  type PopperArrowProps,
+  PopperContent,
+  type PopperContentProps,
+  type PopperProps,
+  Root,
+  SIDE_OPTIONS,
+  createPopperScope,
+};
diff --git a/dist/index.mjs b/dist/index.mjs
index 1ae96b200865a38c5ba43c16722888be632a906f..3143aab5a8bec75454330b87513c92f062b989d4 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -11,7 +11,7 @@ import {
   hide,
   arrow as floatingUIarrow,
   flip,
-  size
+  size,
 } from "@floating-ui/react-dom";
 import * as ArrowPrimitive from "@radix-ui/react-arrow";
 import { useComposedRefs } from "@radix-ui/react-compose-refs";
@@ -29,173 +29,198 @@ var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
 var Popper = (props) => {
   const { __scopePopper, children } = props;
   const [anchor, setAnchor] = React.useState(null);
-  return /* @__PURE__ */ jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
+  return /* @__PURE__ */ jsx(PopperProvider, {
+    scope: __scopePopper,
+    anchor,
+    onAnchorChange: setAnchor,
+    children,
+  });
 };
 Popper.displayName = POPPER_NAME;
 var ANCHOR_NAME = "PopperAnchor";
-var PopperAnchor = React.forwardRef(
-  (props, forwardedRef) => {
-    const { __scopePopper, virtualRef, ...anchorProps } = props;
-    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
-    const ref = React.useRef(null);
-    const composedRefs = useComposedRefs(forwardedRef, ref);
-    React.useEffect(() => {
-      context.onAnchorChange(virtualRef?.current || ref.current);
-    });
-    return virtualRef ? null : /* @__PURE__ */ jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
-  }
-);
+var PopperAnchor = React.forwardRef((props, forwardedRef) => {
+  const { __scopePopper, virtualRef, ...anchorProps } = props;
+  const context = usePopperContext(ANCHOR_NAME, __scopePopper);
+  const ref = React.useRef(null);
+  const composedRefs = useComposedRefs(forwardedRef, ref);
+  React.useEffect(() => {
+    context.onAnchorChange(virtualRef?.current || ref.current);
+  });
+  return virtualRef
+    ? null
+    : /* @__PURE__ */ jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
+});
 PopperAnchor.displayName = ANCHOR_NAME;
 var CONTENT_NAME = "PopperContent";
-var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);
-var PopperContent = React.forwardRef(
-  (props, forwardedRef) => {
-    const {
-      __scopePopper,
-      side = "bottom",
-      sideOffset = 0,
-      align = "center",
-      alignOffset = 0,
-      arrowPadding = 0,
-      avoidCollisions = true,
-      collisionBoundary = [],
-      collisionPadding: collisionPaddingProp = 0,
-      sticky = "partial",
-      hideWhenDetached = false,
-      updatePositionStrategy = "optimized",
-      onPlaced,
-      ...contentProps
-    } = props;
-    const context = usePopperContext(CONTENT_NAME, __scopePopper);
-    const [content, setContent] = React.useState(null);
-    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
-    const [arrow, setArrow] = React.useState(null);
-    const arrowSize = useSize(arrow);
-    const arrowWidth = arrowSize?.width ?? 0;
-    const arrowHeight = arrowSize?.height ?? 0;
-    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
-    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
-    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
-    const hasExplicitBoundaries = boundary.length > 0;
-    const detectOverflowOptions = {
-      padding: collisionPadding,
-      boundary: boundary.filter(isNotNull),
-      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
-      altBoundary: hasExplicitBoundaries
-    };
-    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
+var [PopperContentProvider, useContentContext] =
+  createPopperContext(CONTENT_NAME);
+var PopperContent = React.forwardRef((props, forwardedRef) => {
+  const {
+    __scopePopper,
+    side = "bottom",
+    sideOffset = 0,
+    align = "center",
+    alignOffset = 0,
+    arrowPadding = 0,
+    avoidCollisions = true,
+    collisionBoundary = [],
+    collisionPadding: collisionPaddingProp = 0,
+    sticky = "partial",
+    hideWhenDetached = false,
+    updatePositionStrategy = "optimized",
+    onPlaced,
+    fallbackAxisSideDirection,
+    ...contentProps
+  } = props;
+  const context = usePopperContext(CONTENT_NAME, __scopePopper);
+  const [content, setContent] = React.useState(null);
+  const composedRefs = useComposedRefs(forwardedRef, (node) =>
+    setContent(node)
+  );
+  const [arrow, setArrow] = React.useState(null);
+  const arrowSize = useSize(arrow);
+  const arrowWidth = arrowSize?.width ?? 0;
+  const arrowHeight = arrowSize?.height ?? 0;
+  const desiredPlacement = side + (align !== "center" ? "-" + align : "");
+  const collisionPadding =
+    typeof collisionPaddingProp === "number"
+      ? collisionPaddingProp
+      : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
+  const boundary = Array.isArray(collisionBoundary)
+    ? collisionBoundary
+    : [collisionBoundary];
+  const hasExplicitBoundaries = boundary.length > 0;
+  const detectOverflowOptions = {
+    fallbackAxisSideDirection: fallbackAxisSideDirection,
+    padding: collisionPadding,
+    boundary: boundary.filter(isNotNull),
+    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
+    altBoundary: hasExplicitBoundaries,
+  };
+  const { refs, floatingStyles, placement, isPositioned, middlewareData } =
+    useFloating({
       // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
       strategy: "fixed",
       placement: desiredPlacement,
       whileElementsMounted: (...args) => {
         const cleanup = autoUpdate(...args, {
-          animationFrame: updatePositionStrategy === "always"
+          animationFrame: updatePositionStrategy === "always",
         });
         return cleanup;
       },
       elements: {
-        reference: context.anchor
+        reference: context.anchor,
       },
       middleware: [
-        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
-        avoidCollisions && shift({
-          mainAxis: true,
-          crossAxis: false,
-          limiter: sticky === "partial" ? limitShift() : void 0,
-          ...detectOverflowOptions
+        offset({
+          mainAxis: sideOffset + arrowHeight,
+          alignmentAxis: alignOffset,
         }),
+        avoidCollisions &&
+          shift({
+            mainAxis: true,
+            crossAxis: false,
+            limiter: sticky === "partial" ? limitShift() : void 0,
+            ...detectOverflowOptions,
+          }),
         avoidCollisions && flip({ ...detectOverflowOptions }),
         size({
           ...detectOverflowOptions,
           apply: ({ elements, rects, availableWidth, availableHeight }) => {
-            const { width: anchorWidth, height: anchorHeight } = rects.reference;
+            const { width: anchorWidth, height: anchorHeight } =
+              rects.reference;
             const contentStyle = elements.floating.style;
-            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
-            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
-            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
-            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
-          }
+            contentStyle.setProperty(
+              "--radix-popper-available-width",
+              `${availableWidth}px`
+            );
+            contentStyle.setProperty(
+              "--radix-popper-available-height",
+              `${availableHeight}px`
+            );
+            contentStyle.setProperty(
+              "--radix-popper-anchor-width",
+              `${anchorWidth}px`
+            );
+            contentStyle.setProperty(
+              "--radix-popper-anchor-height",
+              `${anchorHeight}px`
+            );
+          },
         }),
         arrow && floatingUIarrow({ element: arrow, padding: arrowPadding }),
         transformOrigin({ arrowWidth, arrowHeight }),
-        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
-      ]
+        hideWhenDetached &&
+          hide({ strategy: "referenceHidden", ...detectOverflowOptions }),
+      ],
     });
-    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
-    const handlePlaced = useCallbackRef(onPlaced);
-    useLayoutEffect(() => {
-      if (isPositioned) {
-        handlePlaced?.();
-      }
-    }, [isPositioned, handlePlaced]);
-    const arrowX = middlewareData.arrow?.x;
-    const arrowY = middlewareData.arrow?.y;
-    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
-    const [contentZIndex, setContentZIndex] = React.useState();
-    useLayoutEffect(() => {
-      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
-    }, [content]);
-    return /* @__PURE__ */ jsx(
-      "div",
-      {
-        ref: refs.setFloating,
-        "data-radix-popper-content-wrapper": "",
+  const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
+  const handlePlaced = useCallbackRef(onPlaced);
+  useLayoutEffect(() => {
+    if (isPositioned) {
+      handlePlaced?.();
+    }
+  }, [isPositioned, handlePlaced]);
+  const arrowX = middlewareData.arrow?.x;
+  const arrowY = middlewareData.arrow?.y;
+  const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
+  const [contentZIndex, setContentZIndex] = React.useState();
+  useLayoutEffect(() => {
+    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
+  }, [content]);
+  return /* @__PURE__ */ jsx("div", {
+    ref: refs.setFloating,
+    "data-radix-popper-content-wrapper": "",
+    style: {
+      ...floatingStyles,
+      transform: isPositioned
+        ? floatingStyles.transform
+        : "translate(0, -200%)",
+      // keep off the page when measuring
+      minWidth: "max-content",
+      zIndex: contentZIndex,
+      ["--radix-popper-transform-origin"]: [
+        middlewareData.transformOrigin?.x,
+        middlewareData.transformOrigin?.y,
+      ].join(" "),
+      // hide the content if using the hide middleware and should be hidden
+      // set visibility to hidden and disable pointer events so the UI behaves
+      // as if the PopperContent isn't there at all
+      ...(middlewareData.hide?.referenceHidden && {
+        visibility: "hidden",
+        pointerEvents: "none",
+      }),
+    },
+    dir: props.dir,
+    children: /* @__PURE__ */ jsx(PopperContentProvider, {
+      scope: __scopePopper,
+      placedSide,
+      onArrowChange: setArrow,
+      arrowX,
+      arrowY,
+      shouldHideArrow: cannotCenterArrow,
+      children: /* @__PURE__ */ jsx(Primitive.div, {
+        "data-side": placedSide,
+        "data-align": placedAlign,
+        ...contentProps,
+        ref: composedRefs,
         style: {
-          ...floatingStyles,
-          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
-          // keep off the page when measuring
-          minWidth: "max-content",
-          zIndex: contentZIndex,
-          ["--radix-popper-transform-origin"]: [
-            middlewareData.transformOrigin?.x,
-            middlewareData.transformOrigin?.y
-          ].join(" "),
-          // hide the content if using the hide middleware and should be hidden
-          // set visibility to hidden and disable pointer events so the UI behaves
-          // as if the PopperContent isn't there at all
-          ...middlewareData.hide?.referenceHidden && {
-            visibility: "hidden",
-            pointerEvents: "none"
-          }
+          ...contentProps.style,
+          // if the PopperContent hasn't been placed yet (not all measurements done)
+          // we prevent animations so that users's animation don't kick in too early referring wrong sides
+          animation: !isPositioned ? "none" : void 0,
         },
-        dir: props.dir,
-        children: /* @__PURE__ */ jsx(
-          PopperContentProvider,
-          {
-            scope: __scopePopper,
-            placedSide,
-            onArrowChange: setArrow,
-            arrowX,
-            arrowY,
-            shouldHideArrow: cannotCenterArrow,
-            children: /* @__PURE__ */ jsx(
-              Primitive.div,
-              {
-                "data-side": placedSide,
-                "data-align": placedAlign,
-                ...contentProps,
-                ref: composedRefs,
-                style: {
-                  ...contentProps.style,
-                  // if the PopperContent hasn't been placed yet (not all measurements done)
-                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
-                  animation: !isPositioned ? "none" : void 0
-                }
-              }
-            )
-          }
-        )
-      }
-    );
-  }
-);
+      }),
+    }),
+  });
+});
 PopperContent.displayName = CONTENT_NAME;
 var ARROW_NAME = "PopperArrow";
 var OPPOSITE_SIDE = {
   top: "bottom",
   right: "left",
   bottom: "top",
-  left: "right"
+  left: "right",
 };
 var PopperArrow = React.forwardRef(function PopperArrow2(props, forwardedRef) {
   const { __scopePopper, ...arrowProps } = props;
@@ -205,43 +230,37 @@ var PopperArrow = React.forwardRef(function PopperArrow2(props, forwardedRef) {
     // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
     // doesn't report size as we'd expect on SVG elements.
     // it reports their bounding box which is effectively the largest path inside the SVG.
-    /* @__PURE__ */ jsx(
-      "span",
-      {
-        ref: contentContext.onArrowChange,
+    /* @__PURE__ */ jsx("span", {
+      ref: contentContext.onArrowChange,
+      style: {
+        position: "absolute",
+        left: contentContext.arrowX,
+        top: contentContext.arrowY,
+        [baseSide]: 0,
+        transformOrigin: {
+          top: "",
+          right: "0 0",
+          bottom: "center 0",
+          left: "100% 0",
+        }[contentContext.placedSide],
+        transform: {
+          top: "translateY(100%)",
+          right: "translateY(50%) rotate(90deg) translateX(-50%)",
+          bottom: `rotate(180deg)`,
+          left: "translateY(50%) rotate(-90deg) translateX(50%)",
+        }[contentContext.placedSide],
+        visibility: contentContext.shouldHideArrow ? "hidden" : void 0,
+      },
+      children: /* @__PURE__ */ jsx(ArrowPrimitive.Root, {
+        ...arrowProps,
+        ref: forwardedRef,
         style: {
-          position: "absolute",
-          left: contentContext.arrowX,
-          top: contentContext.arrowY,
-          [baseSide]: 0,
-          transformOrigin: {
-            top: "",
-            right: "0 0",
-            bottom: "center 0",
-            left: "100% 0"
-          }[contentContext.placedSide],
-          transform: {
-            top: "translateY(100%)",
-            right: "translateY(50%) rotate(90deg) translateX(-50%)",
-            bottom: `rotate(180deg)`,
-            left: "translateY(50%) rotate(-90deg) translateX(50%)"
-          }[contentContext.placedSide],
-          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
+          ...arrowProps.style,
+          // ensures the element can be measured correctly (mostly for if SVG)
+          display: "block",
         },
-        children: /* @__PURE__ */ jsx(
-          ArrowPrimitive.Root,
-          {
-            ...arrowProps,
-            ref: forwardedRef,
-            style: {
-              ...arrowProps.style,
-              // ensures the element can be measured correctly (mostly for if SVG)
-              display: "block"
-            }
-          }
-        )
-      }
-    )
+      }),
+    })
   );
 });
 PopperArrow.displayName = ARROW_NAME;
@@ -258,7 +277,9 @@ var transformOrigin = (options) => ({
     const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
     const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
     const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
-    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
+    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[
+      placedAlign
+    ];
     const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
     const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
     let x = "";
@@ -277,7 +298,7 @@ var transformOrigin = (options) => ({
       y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
     }
     return { data: { x, y } };
-  }
+  },
 });
 function getSideAndAlignFromPlacement(placement) {
   const [side, align = "center"] = placement.split("-");
@@ -298,6 +319,6 @@ export {
   PopperContent,
   Root2 as Root,
   SIDE_OPTIONS,
-  createPopperScope
+  createPopperScope,
 };
 //# sourceMappingURL=index.mjs.map